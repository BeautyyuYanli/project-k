#!/usr/bin/env -S uv run --script --quiet
# /// script
# requires-python = ">=3.12"
# dependencies = ["aiohttp", "tqdm"]
# ///

"""Fetch URLs via Jina Reader and mirror stdout to a required output file.

`--out` must be a unique path. The script refuses to overwrite existing files to
avoid races across concurrent tool invocations.
"""

from __future__ import annotations

import asyncio
import os
import sys
import argparse


def _write_stdout_and_file(output: str, out_path: str) -> None:
    """Write exactly the same text to a file and stdout."""
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(output)
    sys.stdout.write(output)

async def fetch_url(session: aiohttp.ClientSession, target: str, jina_key: str, use_browser: bool = True) -> str:
    url = f"https://r.jina.ai/{target}"
    headers = {
        "Authorization": f"Bearer {jina_key}",
        "Accept": "text/plain",
    }
    if use_browser:
        headers["X-Experimental"] = "browser"

    try:
        async with session.get(url, headers=headers, timeout=60) as response:
            if response.status == 200:
                return await response.text()
            elif use_browser:
                return await fetch_url(session, target, jina_key, use_browser=False)
            else:
                return f"Error: {response.status} for {target}"
    except Exception as e:
        return f"Error: {str(e)} for {target}"

async def main():
    parser = argparse.ArgumentParser(description="Fetch one or more URLs via Jina Reader")
    parser.add_argument("urls", nargs="+", help="URLs to fetch")
    parser.add_argument(
        "--out",
        required=True,
        help="Output file path (must be unique to avoid races)",
    )
    args = parser.parse_args()

    jina_key = os.environ.get("JINA_AI_KEY")
    if not jina_key:
        print("Error: JINA_AI_KEY environment variable not set.", file=sys.stderr)
        sys.exit(1)

    if os.path.exists(args.out):
        print(f"Error: output file already exists: {args.out}", file=sys.stderr)
        print("Use a unique output file name to avoid race conditions.", file=sys.stderr)
        sys.exit(1)

    async with aiohttp.ClientSession() as session:
        tasks = [fetch_url(session, url, jina_key) for url in args.urls]
        results = await asyncio.gather(*tasks)

    blocks = []
    for i, (url, content) in enumerate(zip(args.urls, results)):
        blocks.append(f"[{i}] URL: {url}\n{content}")
    output = "\n\n".join(blocks)

    _write_stdout_and_file(output, args.out)

if __name__ == "__main__":
    import aiohttp
    asyncio.run(main())
